-- =============================================
-- Contractor Management System - Database Schema
-- Supabase PostgreSQL Schema
-- Generated from Pydantic Models
-- =============================================

-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- =============================================
-- 1. USER PROFILES TABLE
-- =============================================
-- Note: Supabase Auth handles the auth.users table
-- This table stores extended user profile information

CREATE TABLE user_profiles (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    auth_user_id UUID NOT NULL UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT NOT NULL UNIQUE,
    full_name TEXT,
    phone TEXT,
    role TEXT NOT NULL DEFAULT 'user', -- 'user' or 'admin'

    -- Contract/commitment templates
    contract_template TEXT DEFAULT '',
    contractor_commitments TEXT DEFAULT '',
    client_commitments TEXT DEFAULT '',

    -- Timestamps
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    last_login_date TIMESTAMP WITH TIME ZONE
);

-- Index for fast lookups
CREATE INDEX idx_user_profiles_auth_user_id ON user_profiles(auth_user_id);
CREATE INDEX idx_user_profiles_email ON user_profiles(email);

-- =============================================
-- 2. CLIENTS TABLE
-- =============================================

CREATE TABLE clients (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,

    -- Client information
    name TEXT NOT NULL,
    email TEXT,
    phone TEXT,
    company TEXT,
    address TEXT,
    city TEXT,
    notes TEXT,

    -- Timestamps
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_clients_user_id ON clients(user_id);
CREATE INDEX idx_clients_name ON clients(name);
CREATE INDEX idx_clients_email ON clients(email);

-- =============================================
-- 3. CATEGORIES TABLE (for catalog organization)
-- =============================================

CREATE TABLE categories (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),

    -- Category details
    name TEXT NOT NULL UNIQUE,
    description TEXT,
    icon TEXT,
    color TEXT,
    "order" INTEGER DEFAULT 0,

    -- Timestamps
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Index for ordering
CREATE INDEX idx_categories_order ON categories("order");

-- =============================================
-- 4. CATALOG ITEMS TABLE
-- =============================================

CREATE TABLE catalog_items (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    category_id UUID REFERENCES categories(id) ON DELETE SET NULL,

    -- Item details
    name TEXT NOT NULL,
    description TEXT,
    unit TEXT NOT NULL, -- e.g., 'm2', 'unit', 'hour'
    base_price NUMERIC(12, 2) NOT NULL DEFAULT 0,
    contractor_cost NUMERIC(12, 2),
    complexity_factor NUMERIC(5, 2) DEFAULT 1.0,
    is_active BOOLEAN DEFAULT true,

    -- Timestamps
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_catalog_items_category_id ON catalog_items(category_id);
CREATE INDEX idx_catalog_items_name ON catalog_items(name);
CREATE INDEX idx_catalog_items_is_active ON catalog_items(is_active);

-- =============================================
-- 5. PRICE RANGES TABLE (for volume pricing)
-- =============================================

CREATE TABLE price_ranges (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    catalog_item_id UUID NOT NULL REFERENCES catalog_items(id) ON DELETE CASCADE,

    -- Price range
    min_quantity NUMERIC(12, 2) NOT NULL,
    max_quantity NUMERIC(12, 2),
    price NUMERIC(12, 2) NOT NULL
);

-- Index
CREATE INDEX idx_price_ranges_catalog_item_id ON price_ranges(catalog_item_id);

-- =============================================
-- 6. QUOTES TABLE
-- =============================================
-- This is the main quotes table with all fields from your QuoteCreate model

CREATE TABLE quotes (
    -- Auto-generated fields
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    quote_number TEXT UNIQUE, -- Will be auto-generated by trigger

    -- Core identification
    client_id UUID REFERENCES clients(id) ON DELETE SET NULL,
    title TEXT,
    description TEXT,
    status TEXT DEFAULT 'draft' CHECK (status IN ('draft', 'sent', 'approved', 'rejected', 'expired')),

    -- Financial fields (old schema)
    discount_percentage NUMERIC(5, 2) DEFAULT 0,
    discount_amount NUMERIC(12, 2) DEFAULT 0,
    tax_percentage NUMERIC(5, 2) DEFAULT 17, -- Israeli VAT
    tax_amount NUMERIC(12, 2) DEFAULT 0,
    total_cost NUMERIC(12, 2) DEFAULT 0,
    total_price NUMERIC(12, 2) DEFAULT 0,
    profit_amount NUMERIC(12, 2) DEFAULT 0,
    profit_margin NUMERIC(5, 2) DEFAULT 0,

    -- Financial fields (extended schema)
    total_amount NUMERIC(12, 2) DEFAULT 0,
    discount_percent NUMERIC(5, 2) DEFAULT 0,
    price_increase NUMERIC(12, 2) DEFAULT 0,
    final_amount NUMERIC(12, 2) DEFAULT 0,
    estimated_work_days NUMERIC(8, 2),
    estimated_cost NUMERIC(12, 2) DEFAULT 0,
    estimated_profit_percent NUMERIC(5, 2) DEFAULT 0,

    -- Project information
    project_name TEXT,
    project_address TEXT,
    project_type TEXT,

    -- Client information (denormalized for convenience)
    client_name TEXT,
    client_email TEXT,
    client_phone TEXT,

    -- Date fields
    work_days NUMERIC(8, 2),
    general_start_date DATE,
    general_end_date DATE,
    start_date DATE,
    end_date DATE,
    valid_until DATE,
    estimated_duration INTEGER,
    sent_at TIMESTAMP WITH TIME ZONE,
    approved_at TIMESTAMP WITH TIME ZONE,

    -- JSONB fields (flexible data storage)
    items JSONB DEFAULT '[]'::jsonb,
    additional_costs JSONB DEFAULT '[]'::jsonb,
    payment_terms JSONB DEFAULT '[]'::jsonb,
    category_timings JSONB DEFAULT '{}'::jsonb,
    project_complexities JSONB DEFAULT '{}'::jsonb,
    company_info JSONB DEFAULT '{}'::jsonb,
    category_commitments JSONB DEFAULT '{}'::jsonb,
    tiling_work_types JSONB DEFAULT '[]'::jsonb,
    tiling_items JSONB DEFAULT '[]'::jsonb,

    -- Text fields
    notes TEXT,
    terms_and_conditions TEXT,
    created_by TEXT,

    -- Timestamps
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for quotes
CREATE INDEX idx_quotes_user_id ON quotes(user_id);
CREATE INDEX idx_quotes_client_id ON quotes(client_id);
CREATE INDEX idx_quotes_status ON quotes(status);
CREATE INDEX idx_quotes_quote_number ON quotes(quote_number);
CREATE INDEX idx_quotes_created_at ON quotes(created_at DESC);

-- =============================================
-- 7. PROJECTS TABLE
-- =============================================

CREATE TABLE projects (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    client_id UUID REFERENCES clients(id) ON DELETE SET NULL,
    quote_id UUID REFERENCES quotes(id) ON DELETE SET NULL,

    -- Project details
    name TEXT NOT NULL,
    description TEXT,
    status TEXT DEFAULT 'planning' CHECK (status IN ('planning', 'active', 'on-hold', 'completed', 'cancelled')),

    -- Dates
    start_date DATE,
    end_date DATE,
    actual_start_date DATE,
    actual_end_date DATE,

    -- Financial
    budget NUMERIC(12, 2),
    actual_cost NUMERIC(12, 2) DEFAULT 0,

    -- Location
    address TEXT,
    city TEXT,

    -- Notes
    notes TEXT,

    -- Timestamps
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_projects_user_id ON projects(user_id);
CREATE INDEX idx_projects_client_id ON projects(client_id);
CREATE INDEX idx_projects_status ON projects(status);

-- =============================================
-- 8. PROJECT COSTS TABLE
-- =============================================

CREATE TABLE project_costs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE,

    -- Cost details
    category TEXT NOT NULL CHECK (category IN ('labor', 'materials', 'equipment', 'subcontractors', 'other')),
    description TEXT NOT NULL,
    amount NUMERIC(12, 2) NOT NULL,
    date DATE NOT NULL,
    notes TEXT,

    -- Timestamp
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Index
CREATE INDEX idx_project_costs_project_id ON project_costs(project_id);
CREATE INDEX idx_project_costs_date ON project_costs(date);

-- =============================================
-- 9. QUOTE TEMPLATES TABLE
-- =============================================

CREATE TABLE quote_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,

    -- Template details
    name TEXT NOT NULL,
    description TEXT,
    category TEXT,
    is_default BOOLEAN DEFAULT false,

    -- Timestamps
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_quote_templates_user_id ON quote_templates(user_id);

-- =============================================
-- 10. TEMPLATE ITEMS TABLE
-- =============================================

CREATE TABLE template_items (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID NOT NULL REFERENCES quote_templates(id) ON DELETE CASCADE,
    category_id UUID REFERENCES categories(id) ON DELETE SET NULL,
    catalog_item_id UUID REFERENCES catalog_items(id) ON DELETE SET NULL,

    -- Item details
    name TEXT NOT NULL,
    description TEXT,
    unit TEXT NOT NULL,
    quantity NUMERIC(12, 2) NOT NULL,
    unit_price NUMERIC(12, 2) NOT NULL,
    contractor_unit_cost NUMERIC(12, 2),
    item_order INTEGER DEFAULT 0,

    -- Timestamp
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_template_items_template_id ON template_items(template_id);
CREATE INDEX idx_template_items_item_order ON template_items(item_order);

-- =============================================
-- 11. FINANCIAL TRANSACTIONS TABLE
-- =============================================

CREATE TABLE financial_transactions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,

    -- Transaction details
    type TEXT NOT NULL CHECK (type IN ('income', 'expense')),
    category TEXT NOT NULL CHECK (category IN ('quote_payment', 'project_cost', 'supplier_payment', 'salary', 'other')),
    amount NUMERIC(12, 2) NOT NULL,
    description TEXT NOT NULL,
    transaction_date DATE NOT NULL,
    payment_method TEXT CHECK (payment_method IN ('cash', 'bank_transfer', 'check', 'credit_card')),
    reference_number TEXT,

    -- Related entities
    project_id UUID REFERENCES projects(id) ON DELETE SET NULL,
    quote_id UUID REFERENCES quotes(id) ON DELETE SET NULL,
    client_id UUID REFERENCES clients(id) ON DELETE SET NULL,

    notes TEXT,

    -- Timestamps
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_financial_transactions_user_id ON financial_transactions(user_id);
CREATE INDEX idx_financial_transactions_type ON financial_transactions(type);
CREATE INDEX idx_financial_transactions_transaction_date ON financial_transactions(transaction_date);
CREATE INDEX idx_financial_transactions_project_id ON financial_transactions(project_id);

-- =============================================
-- 12. CONTRACTOR PRICING TABLE
-- =============================================

CREATE TABLE contractor_pricing (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    category_id UUID NOT NULL REFERENCES categories(id) ON DELETE CASCADE,

    -- Pricing details
    item_name TEXT NOT NULL,
    unit TEXT NOT NULL,
    base_cost NUMERIC(12, 2) NOT NULL,
    complexity_multiplier NUMERIC(5, 2) DEFAULT 1.0,
    region TEXT,
    notes TEXT,

    -- Timestamps
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_contractor_pricing_user_id ON contractor_pricing(user_id);
CREATE INDEX idx_contractor_pricing_category_id ON contractor_pricing(category_id);

-- =============================================
-- 13. CUSTOMER INQUIRIES TABLE
-- =============================================

CREATE TABLE customer_inquiries (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),

    -- Inquiry details
    name TEXT NOT NULL,
    email TEXT NOT NULL,
    phone TEXT,
    subject TEXT NOT NULL,
    message TEXT NOT NULL,
    status TEXT DEFAULT 'new' CHECK (status IN ('new', 'contacted', 'converted', 'closed')),
    notes TEXT,

    -- Timestamps
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_customer_inquiries_status ON customer_inquiries(status);
CREATE INDEX idx_customer_inquiries_created_at ON customer_inquiries(created_at DESC);

-- =============================================
-- TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply updated_at trigger to all tables with updated_at column
CREATE TRIGGER update_user_profiles_updated_at BEFORE UPDATE ON user_profiles
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_clients_updated_at BEFORE UPDATE ON clients
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_categories_updated_at BEFORE UPDATE ON categories
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_catalog_items_updated_at BEFORE UPDATE ON catalog_items
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_quotes_updated_at BEFORE UPDATE ON quotes
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_projects_updated_at BEFORE UPDATE ON projects
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_quote_templates_updated_at BEFORE UPDATE ON quote_templates
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_financial_transactions_updated_at BEFORE UPDATE ON financial_transactions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_contractor_pricing_updated_at BEFORE UPDATE ON contractor_pricing
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_customer_inquiries_updated_at BEFORE UPDATE ON customer_inquiries
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Function to auto-generate quote numbers
CREATE OR REPLACE FUNCTION generate_quote_number()
RETURNS TRIGGER AS $$
DECLARE
    next_number INTEGER;
    year_part TEXT;
BEGIN
    -- Get current year
    year_part := TO_CHAR(NOW(), 'YYYY');

    -- Get the next number for this year
    SELECT COALESCE(MAX(CAST(SUBSTRING(quote_number FROM '[0-9]+$') AS INTEGER)), 0) + 1
    INTO next_number
    FROM quotes
    WHERE quote_number LIKE 'Q-' || year_part || '-%';

    -- Generate quote number: Q-YYYY-NNNN
    NEW.quote_number := 'Q-' || year_part || '-' || LPAD(next_number::TEXT, 4, '0');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply quote number trigger
CREATE TRIGGER generate_quote_number_trigger BEFORE INSERT ON quotes
    FOR EACH ROW
    WHEN (NEW.quote_number IS NULL)
    EXECUTE FUNCTION generate_quote_number();

-- Function to set user_id from auth context (if using RLS)
CREATE OR REPLACE FUNCTION set_user_id_from_auth()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.user_id IS NULL THEN
        NEW.user_id := auth.uid();
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- ROW LEVEL SECURITY (RLS) POLICIES
-- =============================================
-- Important: Enable RLS and create policies to ensure users can only access their own data

-- Enable RLS on all user-scoped tables
ALTER TABLE user_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE clients ENABLE ROW LEVEL SECURITY;
ALTER TABLE quotes ENABLE ROW LEVEL SECURITY;
ALTER TABLE projects ENABLE ROW LEVEL SECURITY;
ALTER TABLE project_costs ENABLE ROW LEVEL SECURITY;
ALTER TABLE quote_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE template_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE financial_transactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE contractor_pricing ENABLE ROW LEVEL SECURITY;

-- Categories and catalog are shared (no RLS needed)
-- Customer inquiries are public-facing (no RLS needed)

-- USER PROFILES policies
CREATE POLICY "Users can view own profile"
    ON user_profiles FOR SELECT
    USING (auth.uid() = auth_user_id);

CREATE POLICY "Users can update own profile"
    ON user_profiles FOR UPDATE
    USING (auth.uid() = auth_user_id);

CREATE POLICY "Users can insert own profile"
    ON user_profiles FOR INSERT
    WITH CHECK (auth.uid() = auth_user_id);

-- CLIENTS policies
CREATE POLICY "Users can view own clients"
    ON clients FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own clients"
    ON clients FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own clients"
    ON clients FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own clients"
    ON clients FOR DELETE
    USING (auth.uid() = user_id);

-- QUOTES policies
CREATE POLICY "Users can view own quotes"
    ON quotes FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own quotes"
    ON quotes FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own quotes"
    ON quotes FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own quotes"
    ON quotes FOR DELETE
    USING (auth.uid() = user_id);

-- PROJECTS policies
CREATE POLICY "Users can view own projects"
    ON projects FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own projects"
    ON projects FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own projects"
    ON projects FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own projects"
    ON projects FOR DELETE
    USING (auth.uid() = user_id);

-- PROJECT COSTS policies (via project ownership)
CREATE POLICY "Users can view own project costs"
    ON project_costs FOR SELECT
    USING (EXISTS (
        SELECT 1 FROM projects
        WHERE projects.id = project_costs.project_id
        AND projects.user_id = auth.uid()
    ));

CREATE POLICY "Users can insert own project costs"
    ON project_costs FOR INSERT
    WITH CHECK (EXISTS (
        SELECT 1 FROM projects
        WHERE projects.id = project_costs.project_id
        AND projects.user_id = auth.uid()
    ));

CREATE POLICY "Users can update own project costs"
    ON project_costs FOR UPDATE
    USING (EXISTS (
        SELECT 1 FROM projects
        WHERE projects.id = project_costs.project_id
        AND projects.user_id = auth.uid()
    ));

CREATE POLICY "Users can delete own project costs"
    ON project_costs FOR DELETE
    USING (EXISTS (
        SELECT 1 FROM projects
        WHERE projects.id = project_costs.project_id
        AND projects.user_id = auth.uid()
    ));

-- QUOTE TEMPLATES policies
CREATE POLICY "Users can view own templates"
    ON quote_templates FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own templates"
    ON quote_templates FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own templates"
    ON quote_templates FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own templates"
    ON quote_templates FOR DELETE
    USING (auth.uid() = user_id);

-- TEMPLATE ITEMS policies (via template ownership)
CREATE POLICY "Users can view own template items"
    ON template_items FOR SELECT
    USING (EXISTS (
        SELECT 1 FROM quote_templates
        WHERE quote_templates.id = template_items.template_id
        AND quote_templates.user_id = auth.uid()
    ));

CREATE POLICY "Users can insert own template items"
    ON template_items FOR INSERT
    WITH CHECK (EXISTS (
        SELECT 1 FROM quote_templates
        WHERE quote_templates.id = template_items.template_id
        AND quote_templates.user_id = auth.uid()
    ));

CREATE POLICY "Users can update own template items"
    ON template_items FOR UPDATE
    USING (EXISTS (
        SELECT 1 FROM quote_templates
        WHERE quote_templates.id = template_items.template_id
        AND quote_templates.user_id = auth.uid()
    ));

CREATE POLICY "Users can delete own template items"
    ON template_items FOR DELETE
    USING (EXISTS (
        SELECT 1 FROM quote_templates
        WHERE quote_templates.id = template_items.template_id
        AND quote_templates.user_id = auth.uid()
    ));

-- FINANCIAL TRANSACTIONS policies
CREATE POLICY "Users can view own transactions"
    ON financial_transactions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own transactions"
    ON financial_transactions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own transactions"
    ON financial_transactions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own transactions"
    ON financial_transactions FOR DELETE
    USING (auth.uid() = user_id);

-- CONTRACTOR PRICING policies
CREATE POLICY "Users can view own pricing"
    ON contractor_pricing FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own pricing"
    ON contractor_pricing FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own pricing"
    ON contractor_pricing FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own pricing"
    ON contractor_pricing FOR DELETE
    USING (auth.uid() = user_id);

-- CATEGORIES - Public read access (shared catalog)
ALTER TABLE categories ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Everyone can view categories"
    ON categories FOR SELECT
    TO authenticated
    USING (true);

-- CATALOG ITEMS - Public read access (shared catalog)
ALTER TABLE catalog_items ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Everyone can view catalog items"
    ON catalog_items FOR SELECT
    TO authenticated
    USING (true);

-- PRICE RANGES - Public read access (related to catalog)
ALTER TABLE price_ranges ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Everyone can view price ranges"
    ON price_ranges FOR SELECT
    TO authenticated
    USING (true);

-- CUSTOMER INQUIRIES - Public insert, admin view
ALTER TABLE customer_inquiries ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Anyone can submit inquiries"
    ON customer_inquiries FOR INSERT
    TO anon, authenticated
    WITH CHECK (true);

CREATE POLICY "Authenticated users can view inquiries"
    ON customer_inquiries FOR SELECT
    TO authenticated
    USING (true);

-- =============================================
-- SAMPLE DATA (Optional - for testing)
-- =============================================

-- Insert some sample categories
INSERT INTO categories (name, description, icon, color, "order") VALUES
('כללי', 'עבודות כלליות', 'hammer', '#3B82F6', 1),
('חשמל', 'עבודות חשמל', 'zap', '#EF4444', 2),
('אינסטלציה', 'עבודות אינסטלציה', 'droplet', '#10B981', 3),
('ריצוף', 'עבודות ריצוף', 'grid', '#F59E0B', 4),
('צבע', 'עבודות צבע', 'paint-bucket', '#8B5CF6', 5)
ON CONFLICT (name) DO NOTHING;

-- =============================================
-- END OF SCHEMA
-- =============================================

-- Note: After running this schema, you should:
-- 1. Verify all tables were created successfully
-- 2. Test RLS policies with actual user data
-- 3. Create indexes for any additional query patterns you discover
-- 4. Set up backup and recovery procedures
